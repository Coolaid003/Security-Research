# Exploit Tech Overview

The vulnerability is race between unix_gc with unix_stream_sendpage.
Because `unix_stream_sendpage` grab skb without lock. It give unix_gc the chance to conccurent do operation on the sk_receive_queue.
We use timerfd to raise exception handler to extend the race windows, buy more time for unix_gc to free skb and let us cross-cache and spray.
```C
static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
				    int offset, size_t size, int flags)
{
	...

	skb = skb_peek_tail(&other->sk_receive_queue); //nolock and peek the tail skb
	if (tail && tail == skb) {
		skb = newskb;
	} else if (!skb || !unix_skb_scm_eq(skb, &scm)) {
		if (newskb) {
			skb = newskb;
		} else {
			tail = skb;
			goto alloc_skb;
		}
	} else if (newskb) {
		/* this is fast path, we don't necessarily need to
		 * call to kfree_skb even though with newskb == NULL
		 * this - does no harm
		 */
		consume_skb(newskb);
		newskb = NULL;
	}
	// timerfd expire to raise exception handler here, at same time unix_gc is doing free the skb we grabed before
	if (skb_append_pagefrags(skb, page, offset, size)) {
		tail = skb;
		goto alloc_skb;
	}
```

Since skb is freed before enter function `skb_append_pagefrags`. We can forge skb's contents to our control data.
Using this vulnerability, we can insert a skb_frag on an arbitrary kernel address by the following calling path 
skb_append_pagefrags -> skb_fill_page_desc_noacc -> __skb_fill_page_desc_noacc.

```C
static inline void __skb_fill_page_desc_noacc(struct skb_shared_info *shinfo,
					      int i, struct page *page,
					      int off, int size)
{
	skb_frag_t *frag = &shinfo->frags[i];

	/*
	 * Propagate page pfmemalloc to the skb if we can. The problem is
	 * that not all callers have unique ownership of the page but rely
	 * on page_is_pfmemalloc doing the right thing(tm).
	 */
	frag->bv_page		  = page;
	frag->bv_offset		  = off;
	skb_frag_size_set(frag, size);
}

```

According to the skb_frag_t struct layout, bv_offset is more controllable and it's value is between 0 to 0xfff.
We are interested when value is 0, because we can use choose to null first few bytes of a kernel address.
In this case, `struct msg_msg` become our target object again.
```C
typedef struct bio_vec skb_frag_t;
struct bio_vec {
        struct page *              bv_page;                                              /*     0     8 */
        unsigned int               bv_len;                                               /*     8     4 */
        unsigned int               bv_offset;                                            /*    12     4 */

        /* size: 16, cachelines: 1, members: 3 */
        /* last cacheline: 16 bytes */
};
```

Let's take a look into msg_msg struct layout and a sample memory layout of msg_msgs

```C
struct msg_msg {
        struct list_head {
                struct list_head * next;                                                 /*     0     8 */
                struct list_head * prev;                                                 /*     8     8 */
        } m_list; /*     0    16 */
        long int                   m_type;                                               /*    16     8 */
        /* typedef size_t -> __kernel_size_t -> __kernel_ulong_t */ long unsigned int          m_ts; /*    24     8 */
        struct msg_msgseg *        next;                                                 /*    32     8 */
        void *                     security;                                             /*    40     8 */

        /* size: 48, cachelines: 1, members: 5 */
        /* last cacheline: 48 bytes */
};
```

```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0x0000000000000000      0x0000000000000000
0xffff8880082e2400:     0xffff888008705f80      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

If we choose (0xffff8880082e2400+2-0x10) as our skb_frag_t, after return from function `__skb_fill_page_desc_noacc`, the above memory layout will become as follow
```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0xea00001223400000      0x000000001000ffff
0xffff8880082e2400:     0xffff888008700000      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

m_list.next first two byte has been overwrite to null byte and make it point to another msg_msg.
With two msg_msg->m_list.next point to same address, we can use known exploit tech to achieve container escape.


# Exploit Tech Detail

The exploit is consist in the following steps
* EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
* Prepare timerfd
* Spray large amount msg_msg
* Prepare refcount circle to make unix_gc free skbs
* Race between unix_gc with unix_stream_sendpage
* Test UAF write on msg_msg
* Achieve container escape.



## EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
## Prepare timerfd
## Spray large amount msg_msg
## Prepare refcount circle to make unix_gc free skbs
## Race between unix_gc with unix_stream_sendpage
## Test UAF write on msg_msg
## Achieve container escape.


